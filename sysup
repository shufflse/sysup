#!/bin/bash
# sysup ‚Äì Universal system updater 

set -o pipefail

LOGFILE="$HOME/.sysup.log"
exec > >(tee -a "$LOGFILE") 2>&1

# Colours
BOLD="\033[1m"; DIM="\033[2m"; RED="\033[31m"; GREEN="\033[32m"
YELLOW="\033[33m"; CYAN="\033[36m"; RESET="\033[0m"

# Config
CONFIG_DIR="$HOME/.config"
CONFIG_FILE="$CONFIG_DIR/sysup.conf"

init_config() {
  mkdir -p "$CONFIG_DIR"
  cat > "$CONFIG_FILE" <<'EOF'
# sysup configuration file
# Comma-separated lists; leave empty for none
ONLY=()
SKIP=()
# Verbose output: true/false
VERBOSE=false
EOF
  echo -e "${GREEN}‚úî Created default config at $CONFIG_FILE${RESET}"
}

[[ ! -f "$CONFIG_FILE" ]] && init_config
# shellcheck disable=SC1090
source "$CONFIG_FILE"

VERBOSE=${VERBOSE:-false}
declare -a ONLY SKIP

# Updaters 
declare -A updaters=(
  [apt]="apt update && apt upgrade -y"
  [dnf]="dnf upgrade -y"
  [pacman]="pacman -Syu --noconfirm"
  [yay]="yay -Syu --noconfirm"
  [paru]="paru -Syu --noconfirm"
  [zypper]="zypper refresh && zypper update -y"
  [brew]="brew update && brew upgrade"
  [flatpak]="flatpak update -y"
  [npm]="npm update -g"
  [pnpm]="pnpm update -g"
  [yarn]="yarn global upgrade"
  [cargo]="cargo install-update -a"
  [gem]="gem update"
  [go]="go get -u all"
)

# Managers that require root
root_required=(apt dnf pacman zypper npm)

# Conflict groups 
declare -a parallel_groups=(
  "apt dnf pacman yay paru zypper"
  "brew flatpak"
  "npm pnpm yarn"
  "cargo gem go"
)

usage() {
  echo -e "${BOLD}sysup ‚Äì Universal system updater${RESET}

Usage:
  sysup [options]

Options:
  -h, --help         Show this help message and exit
  -v, --verbose      Show full output from each package manager
  -o, --only LIST    Comma-separated list of managers to run (e.g. apt,flatpak)
  -s, --skip LIST    Comma-separated list of managers to skip (e.g. brew,yarn)
  -c, --edit-config  Edit your sysup configuration in \$EDITOR

Examples:
  sysup                  Run updates for all detected managers
  sysup -o apt,flatpak   Update only apt and flatpak
  sysup -s brew          Update everything except Homebrew
  sysup -v               Show full output from each updater"
}

# Parse args
while [[ $# -gt 0 ]]; do
  case $1 in
    -h|--help) usage; exit 0 ;;
    -v|--verbose) VERBOSE=true ;;
    -o|--only) shift; IFS=',' read -ra ONLY <<< "$1" ;;
    --only=*) IFS=',' read -ra ONLY <<< "${1#*=}" ;;
    -s|--skip) shift; IFS=',' read -ra SKIP <<< "$1" ;;
    --skip=*) IFS=',' read -ra SKIP <<< "${1#*=}" ;;
    -c|--edit-config)
      "${EDITOR:-nano}" "$CONFIG_FILE"
      exit 0
      ;;
    *) echo -e "${RED}Unknown option:${RESET} $1"; usage; exit 1 ;;
  esac
  shift
done

# Build active list
ACTIVE_MANAGERS=()
for pm in "${!updaters[@]}"; do
  if [[ ${#ONLY[@]} -gt 0 ]]; then
    [[ " ${ONLY[*]} " != *" $pm "* ]] && continue
  fi
  [[ " ${SKIP[*]} " == *" $pm "* ]] && continue
  command -v "$pm" &>/dev/null || continue
  # Skip pacman if yay/paru present (to avoid double-running pacman)
  if [[ "$pm" == "pacman" ]] && (command -v yay &>/dev/null || command -v paru &>/dev/null); then
    continue
  fi
  ACTIVE_MANAGERS+=("$pm")
done

(( ${#ACTIVE_MANAGERS[@]} == 0 )) && { echo -e "${YELLOW}‚ö† No managers found.${RESET}"; exit 0; }

# Determine if root is needed by any selected manager
NEEDS_ROOT=false
for pm in "${ACTIVE_MANAGERS[@]}"; do
  if [[ " ${root_required[*]} " == *" $pm "* ]]; then
    NEEDS_ROOT=true
    break
  fi
done

# If needed, perform sudo auth first and keep it alive during run
SUDO_PID=""
if $NEEDS_ROOT; then
  echo -e "${CYAN}üîë Authenticating for root-required managers...${RESET}"
  if ! command -v sudo &>/dev/null; then
    echo -e "${RED}‚ùå 'sudo' not found. Install sudo or run managers individually with root.${RESET}"
    exit 1
  fi
  sudo -v || { echo -e "${RED}‚ùå Sudo authentication failed.${RESET}"; exit 1; }
  ( while true; do sudo -n true; sleep 60; done ) & SUDO_PID=$!
  trap '[[ -n "$SUDO_PID" ]] && kill "$SUDO_PID" 2>/dev/null || true' EXIT
fi

# HUD helpers
start_time=$(date +%s)
calc_eta() {
  local done=$1 total=$2 elapsed=$(( $(date +%s) - start_time ))
  (( done == 0 )) && { printf -- "--:--"; return; }
  local avg=$((elapsed / done))
  local remain=$((total - done))
  printf "%02d:%02d" $(( (avg*remain)/60 )) $(( (avg*remain)%60 ))
}

VISIBLE_MANAGERS=("${ACTIVE_MANAGERS[@]}")
draw_ui() {
  local current=$1 total=$2
  local cols=$(tput cols 2>/dev/null || echo 80)
  local lines=$(tput lines 2>/dev/null || echo 24)
  local percent=$(( current * 100 / total ))
  local bar_width=$(( cols - 20 )); (( bar_width < 10 )) && bar_width=10
  local filled=$(( bar_width * current / total ))
  local empty=$(( bar_width - filled ))

  tput sc 2>/dev/null || true
  tput cup $(( lines - 2 )) 0 2>/dev/null || true; tput el 2>/dev/null || true
  printf "${CYAN}Remaining:${RESET} ${YELLOW}%s${RESET}" "${VISIBLE_MANAGERS[*]}"
  tput cup $(( lines - 1 )) 0 2>/dev/null || true; tput el 2>/dev/null || true
  printf "%3d%% ${YELLOW}" "$percent"
  printf "%0.s‚ñà" $(seq 1 $filled)
  printf "${DIM}%0.s‚ñë" $(seq 1 $empty)
  printf "${RESET} ETA:%s" "$(calc_eta "$current" "$total")"
  tput rc 2>/dev/null || true
}

# Execution
COMPLETED=0
FAILURES=()
TOTAL=${#ACTIVE_MANAGERS[@]}
draw_ui 0 "$TOTAL"

# Build groups of active managers
declare -a group_list=()
declare -A group_members

for idx in "${!parallel_groups[@]}"; do
  group_pms=()
  for pm in ${parallel_groups[$idx]}; do
    [[ " ${ACTIVE_MANAGERS[*]} " == *" $pm "* ]] && group_pms+=("$pm")
  done
  (( ${#group_pms[@]} == 0 )) && continue
  group_list+=("$idx")
  group_members[$idx]="${group_pms[*]}"
done

# Run groups in parallel, serialize inside each group
PIDS=()
for idx in "${group_list[@]}"; do
  (
    for pm in ${group_members[$idx]}; do
      cmd="${updaters[$pm]}"
      if [[ " ${root_required[*]} " == *" $pm "* ]]; then
        cmd="sudo bash -lc \"$cmd\""
      else
        cmd="bash -lc \"$cmd\""
      fi

      if $VERBOSE; then
        eval "$cmd"
      else
        eval "$cmd" &>/dev/null
      fi

      status=$?
      # Remove from visible list
      tmp=()
      for v in "${VISIBLE_MANAGERS[@]}"; do
        [[ "$v" == "$pm" ]] || tmp+=("$v")
      done
      VISIBLE_MANAGERS=("${tmp[@]}")

      ((COMPLETED++))
      [[ $status -ne 0 ]] && FAILURES+=("$pm")
      draw_ui "$COMPLETED" "$TOTAL"
    done
  ) &
  PIDS+=("$!")
done

# Wait for all groups to finish
for pid in "${PIDS[@]}"; do
  wait "$pid"
done

# Finalize HUD and report
draw_ui "$TOTAL" "$TOTAL"
tput cup "$(tput lines 2>/dev/null || echo 24)" 0 2>/dev/null || true
echo -e "\n${GREEN}‚úî Updates finished.${RESET}"
if (( ${#FAILURES[@]} > 0 )); then
  echo -e "${RED}‚ùå Failed:${RESET} ${FAILURES[*]}"
fi
